<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Verify — HERMETICUM - BLINDATA · COMPUTABILE · EVOLUTIVA</title>
  <meta name="description" content="Verifica ipr.json e receipt.json: schema + hash + firma ED25519. Client-side. Fail-closed." />
  <style>
    :root{
      --bg:#0b0f14; --panel:#0f1620; --panel2:#0c131c; --txt:#e8eef6; --mut:#a7b3c2;
      --brd:#1d2a3a; --acc:#7dd3fc; --ok:#86efac; --bad:#fda4af; --warn:#fde68a;
      --r:16px; --pad:18px;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
    }
    body{margin:0;background:radial-gradient(900px 600px at 15% 0%, #0d1b2a 0%, var(--bg) 55%);color:var(--txt);}
    .wrap{max-width:1100px;margin:0 auto;padding:26px 18px 60px;}
    header{display:flex;gap:14px;align-items:flex-start;justify-content:space-between;flex-wrap:wrap;margin-bottom:16px}
    .seal{font-weight:900;letter-spacing:.3px}
    .company{color:var(--mut);font-size:12px}
    .tag{color:var(--mut);font-size:13px;line-height:1.45;max-width:560px}
    .grid{display:grid;grid-template-columns:1fr 1fr;gap:16px}
    @media (max-width:980px){.grid{grid-template-columns:1fr}}
    .card{background:linear-gradient(180deg,var(--panel),var(--panel2));border:1px solid var(--brd);border-radius:var(--r);padding:var(--pad);box-shadow:0 10px 30px rgba(0,0,0,.25)}
    .title{font-size:18px;font-weight:800;margin:0 0 8px}
    label{display:block;font-size:12px;color:var(--mut);margin:10px 0 6px}
    textarea{
      width:100%;box-sizing:border-box;background:#071018;border:1px solid var(--brd);
      color:var(--txt);border-radius:12px;padding:10px 12px;outline:none;
      min-height:240px;resize:vertical;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      font-size:12px;line-height:1.35
    }
    .btns{display:flex;gap:10px;flex-wrap:wrap;margin-top:12px}
    button{
      border:1px solid var(--brd);background:#0a1320;color:var(--txt);
      border-radius:12px;padding:10px 12px;font-weight:750;cursor:pointer
    }
    button.primary{border-color:rgba(125,211,252,.6);background:rgba(125,211,252,.1)}
    .status{margin-top:10px;font-size:12px;line-height:1.35}
    .ok{color:var(--ok)} .bad{color:var(--bad)} .warn{color:var(--warn)}
    .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace}
    .out{white-space:pre;overflow:auto;background:#06101a;border:1px solid var(--brd);border-radius:12px;padding:12px;font-size:12px}
    .hr{height:1px;background:var(--brd);margin:14px 0}
  </style>
</head>

<body>
  <div class="wrap">
    <header>
      <div>
        <div class="seal">HERMETICUM - BLINDATA · COMPUTABILE · EVOLUTIVA</div>
        <div class="company">HERMETICUM B.C.E. S.r.l.</div>
      </div>
      <div class="tag">
        Verifica client-side: <b>schema</b> + <b>hash</b> + <b>firma ED25519</b>. Fail-closed: se una cosa stona, FAIL.
      </div>
    </header>

    <section class="card">
      <h1 class="title">Verifica IPR + Receipt</h1>
      <div class="btns">
        <button class="primary" id="run">Esegui verifica</button>
        <button id="clear">Pulisci</button>
      </div>
      <div class="status warn" id="status"></div>
      <div class="hr"></div>
      <div class="out mono" id="finalOut">—</div>
    </section>

    <div class="grid" style="margin-top:16px">
      <section class="card">
        <h2 class="title">ipr.json</h2>
        <label for="iprText">Incolla qui</label>
        <textarea id="iprText" spellcheck="false" placeholder="{ ... }"></textarea>
        <div class="hr"></div>
        <label>Report schema IPR</label>
        <div class="out mono" id="iprReport">—</div>
      </section>

      <section class="card">
        <h2 class="title">receipt.json</h2>
        <label for="rcpText">Incolla qui</label>
        <textarea id="rcpText" spellcheck="false" placeholder="{ ... }"></textarea>
        <div class="hr"></div>
        <label>Report schema Receipt</label>
        <div class="out mono" id="rcpReport">—</div>
      </section>
    </div>
  </div>

<script>
(() => {
  const $ = (id) => document.getElementById(id);

  function setStatus(msg, kind){
    const el = $("status");
    el.className = "status " + (kind || "warn");
    el.textContent = msg || "";
  }

  async function sha256Hex(str){
    const enc = new TextEncoder().encode(str);
    const buf = await crypto.subtle.digest("SHA-256", enc);
    return [...new Uint8Array(buf)].map(b=>b.toString(16).padStart(2,"0")).join("");
  }

  function stableStringify(obj){
    const seen = new WeakSet();
    const norm = (v) => {
      if(v && typeof v === "object"){
        if(seen.has(v)) throw new Error("Cyclic object not allowed");
        seen.add(v);
        if(Array.isArray(v)) return v.map(norm);
        const keys = Object.keys(v).sort();
        const out = {};
        for(const k of keys) out[k] = norm(v[k]);
        return out;
      }
      return v;
    };
    return JSON.stringify(norm(obj));
  }

  function b64ToBuf(b64){
    const bin = atob(b64);
    const bytes = new Uint8Array(bin.length);
    for(let i=0;i<bin.length;i++) bytes[i] = bin.charCodeAt(i);
    return bytes.buffer;
  }

  // Minimal validator (enough for our schemas)
  function validate(schema, data, path="$"){
    const errs = [];
    const isObj = (x) => x && typeof x === "object" && !Array.isArray(x);
    const isIsoZ = (s) => typeof s === "string" && /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d+)?Z$/.test(s);

    const walk = (sch, val, p) => {
      if(!sch) return;

      if(sch.type){
        const t = sch.type;
        const ok =
          (t === "object" && isObj(val)) ||
          (t === "array" && Array.isArray(val)) ||
          (t === "string" && typeof val === "string") ||
          (t === "number" && typeof val === "number") ||
          (t === "integer" && Number.isInteger(val)) ||
          (t === "boolean" && typeof val === "boolean") ||
          (Array.isArray(t) && t.some(tt => (
            (tt==="null" && val===null) ||
            (tt==="object" && isObj(val)) ||
            (tt==="array" && Array.isArray(val)) ||
            (tt==="string" && typeof val === "string") ||
            (tt==="number" && typeof val === "number") ||
            (tt==="integer" && Number.isInteger(val)) ||
            (tt==="boolean" && typeof val === "boolean")
          )));
        if(!ok) errs.push(`${p}: type mismatch (expected ${JSON.stringify(t)})`);
      }

      if("const" in sch && val !== sch.const) errs.push(`${p}: const mismatch`);
      if(sch.enum && !sch.enum.includes(val)) errs.push(`${p}: enum mismatch`);

      if(typeof val === "string"){
        if("minLength" in sch && val.length < sch.minLength) errs.push(`${p}: minLength ${sch.minLength}`);
        if("maxLength" in sch && val.length > sch.maxLength) errs.push(`${p}: maxLength ${sch.maxLength}`);
        if(sch.pattern && !(new RegExp(sch.pattern)).test(val)) errs.push(`${p}: pattern mismatch`);
        if(sch.format === "date-time" && !isIsoZ(val)) errs.push(`${p}: date-time must be ISO with Z`);
      }

      if(typeof val === "number"){
        if("minimum" in sch && val < sch.minimum) errs.push(`${p}: minimum ${sch.minimum}`);
        if("maximum" in sch && val > sch.maximum) errs.push(`${p}: maximum ${sch.maximum}`);
      }

      if(isObj(val)){
        if(Array.isArray(sch.required)){
          for(const k of sch.required){
            if(!(k in val)) errs.push(`${p}: missing required '${k}'`);
          }
        }
        if(sch.additionalProperties === false && sch.properties){
          for(const k of Object.keys(val)){
            if(!(k in sch.properties)) errs.push(`${p}: additional property not allowed '${k}'`);
          }
        }
        if(sch.properties){
          for(const [k, sub] of Object.entries(sch.properties)){
            if(k in val) walk(sub, val[k], `${p}.${k}`);
          }
        }
      }

      if(Array.isArray(val)){
        if("minItems" in sch && val.length < sch.minItems) errs.push(`${p}: minItems ${sch.minItems}`);
        if(sch.uniqueItems){
          const set = new Set(val.map(v => JSON.stringify(v)));
          if(set.size !== val.length) errs.push(`${p}: uniqueItems violated`);
        }
        if(sch.items){
          for(let i=0;i<val.length;i++) walk(sch.items, val[i], `${p}[${i}]`);
        }
      }
    };

    walk(schema, data, path);
    return errs;
  }

  async function fetchJSON(url){
    const r = await fetch(url, { cache: "no-store" });
    if(!r.ok) throw new Error(`Cannot fetch ${url} (${r.status})`);
    return await r.json();
  }

  function basePath(){
    return location.origin + location.pathname.replace(/\/verify\/.*$/, "/");
  }

  async function loadSchemas(){
    const base = basePath();
    const iprUrl = base + "schemas/ipr.schema.json";
    const rcpUrl = base + "schemas/receipt.schema.json";
    const [iprSchema, rcpSchema] = await Promise.all([fetchJSON(iprUrl), fetchJSON(rcpUrl)]);
    return { iprSchema, rcpSchema, iprUrl, rcpUrl };
  }

  function report(el, ok, errs){
    el.textContent = (ok ? "OK ✅\n" : "FAIL ❌\n") + (errs?.length ? errs.join("\n") : "");
  }

  $("run").onclick = async () => {
    $("iprReport").textContent = "—";
    $("rcpReport").textContent = "—";
    $("finalOut").textContent = "—";

    let ipr, rcp;
    try{ ipr = JSON.parse($("iprText").value); }
    catch{ setStatus("ipr.json non è JSON valido.", "bad"); return; }

    try{ rcp = JSON.parse($("rcpText").value); }
    catch{ setStatus("receipt.json non è JSON valido.", "bad"); return; }

    let schemas;
    try{ schemas = await loadSchemas(); }
    catch(e){
      setStatus("Impossibile caricare gli schemi da /schemas.", "bad");
      $("finalOut").textContent = String(e?.message || e);
      return;
    }

    const iprErrs = validate(schemas.iprSchema, ipr, "$");
    const rcpErrs = validate(schemas.rcpSchema, rcp, "$");

    report($("iprReport"), iprErrs.length === 0, iprErrs);
    report($("rcpReport"), rcpErrs.length === 0, rcpErrs);

    const checks = [];
    let ok = true;

    if(iprErrs.length){ ok = false; checks.push("FAIL: schema IPR non valido."); }
    else checks.push("OK: schema IPR valido.");

    if(rcpErrs.length){ ok = false; checks.push("FAIL: schema Receipt non valido."); }
    else checks.push("OK: schema Receipt valido.");

    // hashes
    const iprHash = await sha256Hex(stableStringify(ipr));
    const payloadHash = await sha256Hex(stableStringify(rcp.payload));

    const declaredIprHash = rcp?.payload?.ipr_hash_sha256;
    if(typeof declaredIprHash !== "string"){
      ok = false; checks.push("FAIL: receipt.payload.ipr_hash_sha256 mancante.");
    }else if(declaredIprHash !== iprHash){
      ok = false;
      checks.push("FAIL: receipt.payload.ipr_hash_sha256 mismatch.");
      checks.push(`  declared: ${declaredIprHash}`);
      checks.push(`  computed: ${iprHash}`);
    }else checks.push("OK: ipr_hash_sha256 coincide.");

    const declaredPayloadHash = rcp?.payload_hash_sha256;
    if(typeof declaredPayloadHash !== "string"){
      ok = false; checks.push("FAIL: receipt.payload_hash_sha256 mancante.");
    }else if(declaredPayloadHash !== payloadHash){
      ok = false;
      checks.push("FAIL: receipt.payload_hash_sha256 mismatch.");
      checks.push(`  declared: ${declaredPayloadHash}`);
      checks.push(`  computed: ${payloadHash}`);
    }else checks.push("OK: payload_hash_sha256 coincide.");

    // linkage
    if(ipr?.subject && rcp?.payload?.ipr_subject && ipr.subject !== rcp.payload.ipr_subject){
      ok = false; checks.push("FAIL: subject mismatch tra ipr.subject e receipt.payload.ipr_subject.");
    } else checks.push("OK: subject coerente.");

    if(stableStringify(ipr?.policy || {}) !== stableStringify(rcp?.payload?.policy || {})){
      ok = false; checks.push("FAIL: policy mismatch tra IPR e receipt payload.");
    } else checks.push("OK: policy coerente.");

    // signature ED25519 (fail-closed if scheme is ED25519)
    const sig = rcp?.signature || {};
    if(sig.scheme === "ED25519"){
      try{
        if(!sig.public_key_jwk || !sig.value){
          ok = false;
          checks.push("FAIL: signature ED25519 incompleta (public_key_jwk/value).");
        }else{
          const pubKey = await crypto.subtle.importKey(
            "jwk",
            sig.public_key_jwk,
            { name: "Ed25519" },
            false,
            ["verify"]
          );

          const verified = await crypto.subtle.verify(
            { name: "Ed25519" },
            pubKey,
            b64ToBuf(sig.value),
            new TextEncoder().encode(payloadHash)
          );

          if(!verified){
            ok = false;
            checks.push("FAIL: firma ED25519 non valida.");
          }else{
            checks.push("OK: firma ED25519 verificata.");
          }
        }
      }catch(e){
        ok = false;
        checks.push("FAIL: errore verifica firma ED25519: " + (e?.message || String(e)));
      }
    }else if(sig.scheme === "NONE"){
      checks.push("WARN: receipt non firmata (scheme NONE).");
    }else{
      ok = false;
      checks.push("FAIL: scheme firma sconosciuto (fail-closed).");
    }

    $("finalOut").textContent =
      (ok ? "VERIFICA OK ✅\n\n" : "VERIFICA FAIL ❌ (fail-closed)\n\n") + checks.join("\n");

    setStatus(ok ? "Verifica OK: schema + hash + firma coerenti." : "Verifica FALLITA: vedi dettagli.", ok ? "ok" : "bad");
  };

  $("clear").onclick = () => {
    $("iprText").value = "";
    $("rcpText").value = "";
    $("iprReport").textContent = "—";
    $("rcpReport").textContent = "—";
    $("finalOut").textContent = "—";
    setStatus("", "warn");
  };
})();
</script>
</body>
</html>
