<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Evidence Pack — HERMETICUM - BLINDATA · COMPUTABILE · EVOLUTIVA</title>
  <meta name="description" content="Costruisci Evidence Pack client-side: ipr+receipt+anchor-pack+README_proof + PACK_MANIFEST firmato ED25519 (KEYPACK). HARD SESSION, fail-closed, no custody." />
  <meta name="color-scheme" content="dark light">

  <!-- CSP (incrementale: inline ok, niente script esterni, nessuna rete) -->
  <meta http-equiv="Content-Security-Policy" content="
    default-src 'self';
    base-uri 'self';
    object-src 'none';
    frame-ancestors 'none';
    form-action 'none';
    img-src 'self' data:;
    style-src 'self' 'unsafe-inline';
    script-src 'self' 'unsafe-inline';
    connect-src 'self';
    font-src 'self';
    upgrade-insecure-requests;
  ">
  <meta http-equiv="Referrer-Policy" content="no-referrer">
  <meta http-equiv="X-Content-Type-Options" content="nosniff">

  <style>
    :root{
      --bg:#0b0f14; --panel:#0f1620; --panel2:#0c131c; --txt:#e8eef6; --mut:#a7b3c2;
      --brd:#1d2a3a; --acc:#7dd3fc; --ok:#86efac; --bad:#fda4af; --warn:#fde68a;
      --r:16px; --pad:18px;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
    }
    body{margin:0;background:radial-gradient(1000px 680px at 15% 0%, #0d1b2a 0%, var(--bg) 55%);color:var(--txt);}
    a{color:var(--acc);text-decoration:none}
    .wrap{max-width:1200px;margin:0 auto;padding:26px 18px 60px;}
    header{display:flex;justify-content:space-between;gap:14px;align-items:flex-start;flex-wrap:wrap;margin-bottom:16px}
    .seal{font-weight:900;letter-spacing:.3px}
    .company{color:var(--mut);font-size:12px;margin-top:4px}
    .tag{color:var(--mut);font-size:13px;line-height:1.45;max-width:780px}
    .pill{display:inline-block;border:1px solid var(--brd);border-radius:999px;padding:6px 10px;font-size:12px;color:var(--mut);margin-top:6px}
    .grid{display:grid;grid-template-columns:1.1fr .9fr;gap:16px}
    @media (max-width:980px){.grid{grid-template-columns:1fr}}
    .card{background:linear-gradient(180deg,var(--panel),var(--panel2));border:1px solid var(--brd);border-radius:var(--r);padding:var(--pad);box-shadow:0 10px 30px rgba(0,0,0,.25)}
    .title{font-size:18px;font-weight:800;margin:0 0 8px}
    .sub{color:var(--mut);font-size:12px;line-height:1.4;margin:0 0 10px}
    label{display:block;font-size:12px;color:var(--mut);margin:10px 0 6px}
    input, textarea{
      width:100%;box-sizing:border-box;background:#071018;border:1px solid var(--brd);
      color:var(--txt);border-radius:12px;padding:10px 12px;outline:none;
      font-size:13px;line-height:1.35
    }
    textarea{
      min-height:160px;resize:vertical;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      font-size:12px
    }
    .btns{display:flex;gap:10px;flex-wrap:wrap;margin-top:12px}
    button{
      border:1px solid var(--brd);background:#0a1320;color:var(--txt);
      border-radius:12px;padding:10px 12px;font-weight:750;cursor:pointer
    }
    button.primary{border-color:rgba(125,211,252,.6);background:rgba(125,211,252,.1)}
    button:disabled{opacity:.45;cursor:not-allowed}
    .hr{height:1px;background:var(--brd);margin:14px 0}
    .out{white-space:pre;overflow:auto;background:#06101a;border:1px solid var(--brd);border-radius:12px;padding:12px;font-size:12px}
    .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace}
    .status{margin-top:10px;font-size:12px;line-height:1.35}
    .ok{color:var(--ok)} .bad{color:var(--bad)} .warn{color:var(--warn)}
    .row{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
    .check{display:flex;gap:10px;align-items:center}
    .small{font-size:12px;color:var(--mut)}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <div class="seal">HERMETICUM - BLINDATA · COMPUTABILE · EVOLUTIVA</div>
        <div class="company">HERMETICUM B.C.E. S.r.l.</div>
        <div class="pill">Evidence Pack · PACK_MANIFEST firmato · HARD SESSION · fail-closed</div>
      </div>
      <div class="tag">
        Costruisci un pacchetto verificabile: <b>IPR</b> + <b>Receipt</b> + (opz.) <b>Anchor Pack</b> + <b>README_proof</b> + <b>PACK_MANIFEST firmato ED25519</b>.
        La firma usa <b>SIGNING_KEYPACK</b> (chiave privata cifrata). Nessun invio. Nessuno storage obbligatorio.
      </div>
    </header>

    <div class="grid">
      <section class="card">
        <h1 class="title">Input</h1>
        <p class="sub">
          Incolla i JSON. Poi “Build & Sign” genera i file e i relativi hash. Modello: hash-only, audit-first, fail-closed.
        </p>

        <label for="ipr">ipr.json</label>
        <textarea id="ipr" spellcheck="false" placeholder="{ ... }"></textarea>

        <label for="rcp">receipt.json</label>
        <textarea id="rcp" spellcheck="false" placeholder="{ ... }"></textarea>

        <label for="ap">anchor-pack.json (opzionale)</label>
        <textarea id="ap" spellcheck="false" placeholder="{ ... }"></textarea>

        <div class="hr"></div>

        <h2 class="title" style="font-size:16px">SIGNING_KEYPACK (obbligatorio per firmare)</h2>
        <p class="sub">
          Inserisci <code>SIGNING_KEYPACK.json</code> e passphrase. La chiave privata viene decrittata solo per firmare e poi rimossa.
        </p>

        <label for="kp">SIGNING_KEYPACK.json</label>
        <textarea id="kp" spellcheck="false" placeholder="{ ... }"></textarea>

        <label for="kpPass">Passphrase KEYPACK</label>
        <input id="kpPass" type="password" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false"
               placeholder="Passphrase (non salvata)" />

        <div class="row" style="margin-top:10px">
          <label class="check">
            <input type="checkbox" id="hardSession" checked />
            HARD SESSION (decrypt-only-for-sign + wipe + timeout)
          </label>
          <span class="small" id="sessStatus"></span>
        </div>

        <div class="btns">
          <button class="primary" id="build">Build & Sign</button>
          <button id="wipeNow">Wipe Now</button>
        </div>

        <div class="status warn" id="status"></div>

        <div class="hr"></div>

        <div class="btns">
          <button id="dlManifest" disabled>Scarica PACK_MANIFEST.json</button>
          <button id="dlReadme" disabled>Scarica README_proof.md</button>
          <button id="dlAnchorPack" disabled>Scarica anchor-pack.json</button>
        </div>
      </section>

      <section class="card">
        <h2 class="title">Output (preview)</h2>

        <label>README_proof.md</label>
        <div class="out mono" id="readmeOut">—</div>

        <div class="hr"></div>

        <label>PACK_MANIFEST.json</label>
        <div class="out mono" id="manifestOut">—</div>

        <div class="hr"></div>

        <label>Hashes (files map)</label>
        <div class="out mono" id="hashOut">—</div>
      </section>
    </div>
  </div>

<script>
(() => {
  const $ = (id) => document.getElementById(id);

  // In-memory only
  let iprObj = null;
  let rcpObj = null;
  let apObj = null;

  let readmeText = null;
  let packManifestObj = null;
  let filesMap = null;

  let sessionTimer = null;

  function setStatus(msg, kind){
    const el = $("status");
    el.className = "status " + (kind || "warn");
    el.textContent = msg || "";
  }

  function nowISO(){ return new Date().toISOString(); }

  // --- helpers ---
  function b64ToBuf(b64){
    const bin = atob(b64);
    const bytes = new Uint8Array(bin.length);
    for(let i=0;i<bin.length;i++) bytes[i] = bin.charCodeAt(i);
    return bytes.buffer;
  }
  function bufToB64(buf){
    const bytes = new Uint8Array(buf);
    let bin = "";
    for(const b of bytes) bin += String.fromCharCode(b);
    return btoa(bin);
  }

  async function sha256Hex(str){
    const enc = new TextEncoder().encode(str);
    const buf = await crypto.subtle.digest("SHA-256", enc);
    return [...new Uint8Array(buf)].map(b=>b.toString(16).padStart(2,"0")).join("");
  }

  function stableStringify(obj){
    const seen = new WeakSet();
    const norm = (v) => {
      if(v && typeof v === "object"){
        if(seen.has(v)) throw new Error("Cyclic object not allowed");
        seen.add(v);
        if(Array.isArray(v)) return v.map(norm);
        const keys = Object.keys(v).sort();
        const out = {};
        for(const k of keys) out[k] = norm(v[k]);
        return out;
      }
      return v;
    };
    return JSON.stringify(norm(obj));
  }

  function downloadText(filename, text, mime){
    const blob = new Blob([text], { type: mime || "text/plain" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }
  function downloadJSON(filename, obj){
    downloadText(filename, JSON.stringify(obj, null, 2), "application/json");
  }

  function enableDownloads(on){
    $("dlManifest").disabled = !on;
    $("dlReadme").disabled = !on;
    // anchor-pack download only if provided/constructed
    $("dlAnchorPack").disabled = !on || !apObj;
  }

  // --- HARD SESSION ---
  function hardWipe(){
    // wipe UI
    for(const id of ["ipr","rcp","ap","kp","kpPass"]){
      const el = $(id);
      if(el) el.value = "";
    }

    // wipe objects
    iprObj = null; rcpObj = null; apObj = null;
    readmeText = null; packManifestObj = null; filesMap = null;

    // wipe outputs
    $("readmeOut").textContent = "—";
    $("manifestOut").textContent = "—";
    $("hashOut").textContent = "—";
    enableDownloads(false);

    $("sessStatus").textContent = "Wipe completato.";
    setStatus("Session wiped (RAM).", "ok");
  }

  function startHardTimeout(ms=120000){
    if(sessionTimer) clearTimeout(sessionTimer);
    sessionTimer = setTimeout(() => {
      hardWipe();
      $("sessStatus").textContent = "Timeout HARD SESSION: dati rimossi dalla sessione.";
    }, ms);
    $("sessStatus").textContent = `HARD SESSION attiva: timeout ${Math.round(ms/1000)}s.`;
  }

  $("hardSession").onchange = () => {
    if($("hardSession").checked) startHardTimeout();
    else {
      if(sessionTimer) clearTimeout(sessionTimer);
      $("sessStatus").textContent = "HARD SESSION disattivata.";
    }
  };

  $("wipeNow").onclick = () => hardWipe();

  // --- KEYPACK crypto: AES-GCM + PBKDF2 (same format as /create/) ---
  async function deriveAesKeyFromPass(pass, saltB64){
    const salt = new Uint8Array(b64ToBuf(saltB64));
    const baseKey = await crypto.subtle.importKey(
      "raw",
      new TextEncoder().encode(pass),
      "PBKDF2",
      false,
      ["deriveKey"]
    );
    return await crypto.subtle.deriveKey(
      { name: "PBKDF2", salt, iterations: 200000, hash: "SHA-256" },
      baseKey,
      { name: "AES-GCM", length: 256 },
      false,
      ["decrypt"]
    );
  }

  async function aesGcmDecryptJSON(pass, wrapped){
    const key = await deriveAesKeyFromPass(pass, wrapped.salt_b64);
    const pt = await crypto.subtle.decrypt(
      { name:"AES-GCM", iv: new Uint8Array(b64ToBuf(wrapped.iv_b64)) },
      key,
      b64ToBuf(wrapped.ct_b64)
    );
    const text = new TextDecoder().decode(pt);
    return JSON.parse(text);
  }

  async function importEd25519PrivateJwk(jwk){
    return await crypto.subtle.importKey("jwk", jwk, { name:"Ed25519" }, false, ["sign"]);
  }

  async function signEd25519OverText(privKey, text){
    const sigBuf = await crypto.subtle.sign(
      { name: "Ed25519" },
      privKey,
      new TextEncoder().encode(text)
    );
    return bufToB64(sigBuf);
  }

  function fail(msg){
    throw new Error(msg);
  }

  function normalizeJSONText(t){
    const s = (t || "").trim();
    return s;
  }

  // --- Build README proof ---
  function buildReadmeProof(meta){
    const lines = [];
    lines.push("# Evidence Pack — Proof Snapshot");
    lines.push("");
    lines.push("Questo file descrive un pacchetto minimo verificabile (hash-only) generato client-side.");
    lines.push("Nessuna custodia. Nessun invio a server. Modello: UE-FIRST / GDPR-MIN / HASH-ONLY / FAIL-CLOSED.");
    lines.push("");
    lines.push("## Meta");
    lines.push(`- time_utc: ${meta.issued_at}`);
    lines.push(`- subject: ${meta.subject}`);
    lines.push(`- receipt.kid: ${meta.kid || "n/a"}`);
    lines.push("");
    lines.push("## Files (sha256)");
    for(const k of Object.keys(meta.files).sort()){
      lines.push(`- ${k}: ${meta.files[k]}`);
    }
    lines.push("");
    lines.push("## Notes");
    lines.push("- Il controllo della firma ED25519 e degli hash è previsto in /verify/.");
    lines.push("- Anchors (BTC/ETH/IPFS) se presenti restano riferimenti: la validità dipende dalle reti.");
    lines.push("");
    return lines.join("\n");
  }

  // --- MAIN ---
  async function buildAndSign(){
    if($("hardSession").checked) startHardTimeout();

    setStatus("Build in corso…", "warn");
    enableDownloads(false);

    // Parse required JSON
    const iprText = normalizeJSONText($("ipr").value);
    const rcpText = normalizeJSONText($("rcp").value);
    if(!iprText) fail("ipr.json mancante.");
    if(!rcpText) fail("receipt.json mancante.");

    try{ iprObj = JSON.parse(iprText); } catch { fail("ipr.json non è JSON valido."); }
    try{ rcpObj = JSON.parse(rcpText); } catch { fail("receipt.json non è JSON valido."); }

    // Optional anchor pack
    const apText = normalizeJSONText($("ap").value);
    apObj = null;
    if(apText){
      try{ apObj = JSON.parse(apText); }
      catch{ fail("anchor-pack.json non è JSON valido."); }
    }

    // Fail-closed header checks
    if(iprObj?.proto !== "AI_JOKER_C2" || iprObj?.type !== "IPR_PACKAGE" || iprObj?.version !== "v1") fail("IPR header non valido.");
    if(rcpObj?.proto !== "AI_JOKER_C2" || rcpObj?.type !== "RECEIPT" || rcpObj?.version !== "v1") fail("Receipt header non valido.");
    if(rcpObj?.signature?.scheme !== "ED25519") fail("Receipt non è ED25519 (fail-closed).");
    if(!rcpObj?.signature?.public_key_jwk || !rcpObj?.signature?.kid) fail("Receipt signature incompleta (public_key_jwk/kid).");

    // Compute ipr hash + receipt hashes
    const iprHash = await sha256Hex(stableStringify(iprObj));
    const receiptPayloadHash = rcpObj?.payload_hash_sha256;
    if(typeof receiptPayloadHash !== "string" || receiptPayloadHash.length !== 64) fail("receipt.payload_hash_sha256 non valido.");

    const receiptFullHash = await sha256Hex(stableStringify(rcpObj));

    // Optional anchor-pack hash
    const anchorPackHash = apObj ? await sha256Hex(stableStringify(apObj)) : null;

    // Build README first (so it can be hashed and placed in files map)
    filesMap = {
      "ipr.json": iprHash,
      "receipt.payload_hash_sha256": receiptPayloadHash,
      "receipt.full_hash_sha256": receiptFullHash
    };
    if(anchorPackHash) filesMap["anchor-pack.json"] = anchorPackHash;

    const metaForReadme = {
      issued_at: nowISO(),
      subject: iprObj.subject || "n/a",
      kid: rcpObj.signature.kid,
      files: filesMap
    };
    readmeText = buildReadmeProof(metaForReadme);
    const readmeHash = await sha256Hex(readmeText);
    filesMap["README_proof.md"] = readmeHash;

    // Require keypack to sign pack manifest
    const kpText = normalizeJSONText($("kp").value);
    const kpPass = ($("kpPass").value || "").trim();
    if(!kpText) fail("SIGNING_KEYPACK.json mancante (necessario per firmare PACK_MANIFEST).");
    if(kpPass.length < 10) fail("Passphrase KEYPACK troppo corta (min 10).");

    let keypack = null;
    try{ keypack = JSON.parse(kpText); } catch { fail("SIGNING_KEYPACK.json non è JSON valido."); }

    if(keypack?.proto !== "AI_JOKER_C2" || keypack?.type !== "SIGNING_KEYPACK" || keypack?.version !== "v1") fail("KEYPACK header non valido.");
    if(!keypack?.wrapped_private_jwk || !keypack?.public_key_jwk || !keypack?.kid) fail("KEYPACK incompleto.");
    if(keypack.kid !== rcpObj.signature.kid) fail("KEYPACK kid != receipt kid (continuità firma fallita).");

    // Build PACK_MANIFEST (without signature)
    const pmNoSig = {
      proto: "AI_JOKER_C2",
      type: "PACK_MANIFEST",
      version: "v1",
      issued_at: nowISO(),
      subject: iprObj.subject || null,
      policy: "UE-FIRST/GDPR-MIN/HASH-ONLY/AUDIT",
      files: filesMap,
      pack_hash_sha256: null
      // pack_signature will be added after hashing
    };

    const computedPackHash = await sha256Hex(stableStringify(pmNoSig));
    pmNoSig.pack_hash_sha256 = computedPackHash;

    // Decrypt private key ONLY to sign (HARD SESSION principle)
    const privateJwk = await aesGcmDecryptJSON(kpPass, keypack.wrapped_private_jwk);
    const privKey = await importEd25519PrivateJwk(privateJwk);

    const sigB64 = await signEd25519OverText(privKey, pmNoSig.pack_hash_sha256);

    // wipe decrypted material best-effort
    for(const k of Object.keys(privateJwk)) privateJwk[k] = null;

    // Final manifest
    packManifestObj = {
      ...pmNoSig,
      pack_signature: {
        scheme: "ED25519",
        kid: keypack.kid,
        value: sigB64,
        public_key_jwk: keypack.public_key_jwk
      }
    };

    // HARD SESSION: remove keypack and passphrase after signing
    if($("hardSession").checked){
      $("kp").value = "";
      $("kpPass").value = "";
      $("sessStatus").textContent = "KEYPACK e passphrase rimossi (HARD SESSION).";
    }

    // Output previews
    $("readmeOut").textContent = readmeText;
    $("manifestOut").textContent = JSON.stringify(packManifestObj, null, 2);
    $("hashOut").textContent = JSON.stringify(filesMap, null, 2);

    enableDownloads(true);
    setStatus("OK: Evidence Pack costruito. PACK_MANIFEST firmato ED25519 (kid continuity OK).", "ok");
  }

  $("build").onclick = async () => {
    try{
      await buildAndSign();
    }catch(e){
      console.error(e);
      setStatus("FAIL: " + (e?.message || String(e)), "bad");
      enableDownloads(false);
    }
  };

  $("dlManifest").onclick = () => {
    if(!packManifestObj) return;
    downloadJSON("PACK_MANIFEST.json", packManifestObj);
  };

  $("dlReadme").onclick = () => {
    if(!readmeText) return;
    downloadText("README_proof.md", readmeText, "text/markdown");
  };

  $("dlAnchorPack").onclick = () => {
    if(!apObj) return;
    downloadJSON("anchor-pack.json", apObj);
  };

  // init
  hardWipe();
})();
</script>
</body>
</html>
